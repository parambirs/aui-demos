(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['exports', 'module', './jquery', './internal/alignment', './internal/amdify', './internal/attributes', './internal/enforcer', './internal/globalize', './layer', './internal/skate', './internal/state'], factory);
    } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
        factory(exports, module, require('./jquery'), require('./internal/alignment'), require('./internal/amdify'), require('./internal/attributes'), require('./internal/enforcer'), require('./internal/globalize'), require('./layer'), require('./internal/skate'), require('./internal/state'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, mod, global.$, global.Alignment, global.amdify, global.attributes, global.enforce, global.globalize, global.layer, global.skate, global.state);
        global.inlineDialog2 = mod.exports;
    }
})(this, function (exports, module, _jquery, _internalAlignment, _internalAmdify, _internalAttributes, _internalEnforcer, _internalGlobalize, _layer, _internalSkate, _internalState) {
    'use strict';

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    var _$ = _interopRequireDefault(_jquery);

    var _Alignment = _interopRequireDefault(_internalAlignment);

    var _amdify = _interopRequireDefault(_internalAmdify);

    var _attributes = _interopRequireDefault(_internalAttributes);

    var _enforce = _interopRequireDefault(_internalEnforcer);

    var _globalize = _interopRequireDefault(_internalGlobalize);

    var _layer2 = _interopRequireDefault(_layer);

    var _skate = _interopRequireDefault(_internalSkate);

    var _state = _interopRequireDefault(_internalState);

    var DEFAULT_HOVEROUT_DELAY = 1000;

    function getTrigger(element) {
        return document.querySelector('[aria-controls="' + element.id + '"]');
    }

    function doIfTrigger(element, callback) {
        var trigger = getTrigger(element);

        if (trigger) {
            callback(trigger);
        }
    }

    function initAlignment(element, trigger) {
        if (!element._auiAlignment) {
            element._auiAlignment = new _Alignment['default'](element, trigger);
        }
    }

    function enableAlignment(element, trigger) {
        initAlignment(element, trigger);
        element._auiAlignment.enable();
    }

    function disableAlignment(element, trigger) {
        initAlignment(element, trigger);
        element._auiAlignment.disable();
    }

    function handleMessage(element, message) {
        var messageTypeMap = {
            toggle: ['click'],
            hover: ['mouseenter', 'mouseleave', 'focus', 'blur']
        };

        var messageList = messageTypeMap[element.respondsTo];
        if (messageList && messageList.indexOf(message.type) > -1) {
            messageHandler[message.type](element, message);
        }
    }

    var messageHandler = {
        click: function click(element) {
            if (element.open) {
                if (!(0, _layer2['default'])(element).isPersistent()) {
                    element.open = false;
                }
            } else {
                element.open = true;
            }
        },

        mouseenter: function mouseenter(element) {
            if (!element.open) {
                element.open = true;
            }

            if (element._clearMouseleaveTimeout) {
                element._clearMouseleaveTimeout();
            }
        },

        mouseleave: function mouseleave(element) {
            if ((0, _layer2['default'])(element).isPersistent() || !element.open) {
                return;
            }

            if (element._clearMouseleaveTimeout) {
                element._clearMouseleaveTimeout();
            }

            var timeout = setTimeout(function () {
                if (!(0, _state['default'])(element).get('mouse-inside')) {
                    element.open = false;
                }
            }, DEFAULT_HOVEROUT_DELAY);

            element._clearMouseleaveTimeout = function () {
                clearTimeout(timeout);
                element._clearMouseleaveTimeout = null;
            };
        },

        focus: function focus(element) {
            if (!element.open) {
                element.open = true;
            }
        },

        blur: function blur(element) {
            if (!(0, _layer2['default'])(element).isPersistent() && element.open) {
                element.open = false;
            }
        }
    };

    function onMouseEnter(e) {
        var element = e.target;
        (0, _state['default'])(element).set('mouse-inside', true);
        element.message({
            type: 'mouseenter'
        });
    }

    function onMouseLeave(e) {
        var element = e.target;
        (0, _state['default'])(element).set('mouse-inside', false);
        element.message({
            type: 'mouseleave'
        });
    }

    function rebindMouseEvents(el) {
        (0, _state['default'])(el).set('mouse-inside', undefined);
        el.removeEventListener('mouseenter', onMouseEnter);
        el.removeEventListener('mouseleave', onMouseLeave);

        if (el.respondsTo === 'hover') {
            (0, _state['default'])(el).set('mouse-inside', false);
            el.addEventListener('mouseenter', onMouseEnter);
            el.addEventListener('mouseleave', onMouseLeave);
        }
    }

    function showInlineDialog(el) {
        (0, _layer2['default'])(el).show();
        if ((0, _layer2['default'])(el).isVisible()) {
            doIfTrigger(el, function (trigger) {
                enableAlignment(el, trigger);
                trigger.setAttribute('aria-expanded', 'true');
            });
        }
    }

    function hideInlineDialog(el) {
        (0, _layer2['default'])(el).hide();
        if (!(0, _layer2['default'])(el).isVisible()) {
            doIfTrigger(el, function (trigger) {
                disableAlignment(el, trigger);
                trigger.setAttribute('aria-expanded', 'false');
            });
        }
    }

    function reflectOpenness(el) {
        var isInitalizing = !el.hasAttribute('aria-hidden');
        var shouldBeOpen = el.hasAttribute('open');
        if (isInitalizing || el.open !== shouldBeOpen) {
            if (shouldBeOpen) {
                (0, _state['default'])(el).set('is-processing-show', true);
                showInlineDialog(el);
                (0, _state['default'])(el).set('is-processing-show', false);
            } else {
                hideInlineDialog(el);
            }
        }
    }

    var RESPONDS_TO_ATTRIBUTE_ENUM = {
        attribute: 'responds-to',
        values: ['toggle', 'hover'],
        missingDefault: 'toggle',
        invalidDefault: 'toggle'
    };

    var inlineDialog = (0, _skate['default'])('aui-inline-dialog', {
        prototype: Object.defineProperties({

            /**
             * Handles the receiving of a message from another component.
             *
             * @param {Object} msg The message to act on.
             *
             * @returns {HTMLElement}
             */
            message: function message(msg) {
                handleMessage(this, msg);
                return this;
            }
        }, {
            open: {
                /**
                 * Returns whether the inline dialog is open.
                 */

                get: function get() {
                    return (0, _layer2['default'])(this).isVisible();
                },

                /**
                 * Opens or closes the inline dialog, returning whether the dialog is
                 * open or closed as a result (since event handlers can prevent either
                 * action).
                 *
                 * You should check the value of open after setting this
                 * value since the before show/hide events may have prevented it.
                 */
                set: function set(value) {
                    // TODO AUI-3726 Revisit double calls to canceled event handlers.
                    // Explicitly calling reflectOpenness(…) in this setter means
                    // that in native we'll get two sync calls to reflectOpenness(…)
                    // and in polyfill one sync (here) and one async (attr change
                    // handler). The latter of the two calls, for both cases, will
                    // usually be a noop (except when show/hide events are cancelled).
                    _attributes['default'].setBooleanAttribute(this, 'open', value);
                    reflectOpenness(this);
                },
                configurable: true,
                enumerable: true
            },
            persistent: {
                get: function get() {
                    return this.hasAttribute('persistent');
                },
                set: function set(value) {
                    _attributes['default'].setBooleanAttribute(this, 'persistent', value);
                },
                configurable: true,
                enumerable: true
            },
            respondsTo: {
                get: function get() {
                    var attr = RESPONDS_TO_ATTRIBUTE_ENUM.attribute;
                    return _attributes['default'].computeEnumValue(RESPONDS_TO_ATTRIBUTE_ENUM, this.getAttribute(attr));
                },
                set: function set(value) {
                    var oldComputedValue = this.respondsTo;
                    _attributes['default'].setEnumAttribute(this, RESPONDS_TO_ATTRIBUTE_ENUM, value);
                    if (oldComputedValue !== this.respondsTo) {
                        rebindMouseEvents(this);
                    }
                },
                configurable: true,
                enumerable: true
            }
        }),

        created: function created(element) {
            (0, _state['default'])(element).set('is-processing-show', false);

            doIfTrigger(element, function (trigger) {
                trigger.setAttribute('aria-expanded', element.open);
                trigger.setAttribute('aria-haspopup', 'true');
            });
        },

        attributes: {
            'aria-hidden': function ariaHidden(element, change) {
                // Whenever layer manager hides us, we need to sync the open attribute.
                _attributes['default'].setBooleanAttribute(element, 'open', change.newValue === 'false');
            },

            open: function open(element, change) {
                // skate runs the created callback for attributes before the
                // element is attached to the DOM, so guard against that.
                if (document.body.contains(element)) {
                    reflectOpenness(element);
                }
            },

            'responds-to': function respondsTo(element, change) {
                var oldComputedValue = _attributes['default'].computeEnumValue(RESPONDS_TO_ATTRIBUTE_ENUM, change.oldValue);
                var newComputedValue = _attributes['default'].computeEnumValue(RESPONDS_TO_ATTRIBUTE_ENUM, change.newValue);
                if (oldComputedValue !== newComputedValue) {
                    rebindMouseEvents(element);
                }
            }
        },

        attached: function attached(element) {
            (0, _enforce['default'])(element).attributeExists('id');
            if (element.hasAttribute('open')) {
                // show() can cause the element to be reattached (to the <body>),
                // so guard against a nested show() call that blows up the layer
                // manager (since it sees us pushing the same element twice).
                if (!(0, _state['default'])(element).get('is-processing-show')) {
                    reflectOpenness(element);
                }
            } else {
                reflectOpenness(element);
            }
            rebindMouseEvents(element);
        },

        detached: function detached(element) {
            if (element._auiAlignment) {
                element._auiAlignment.destroy();
            }
        },

        template: function template(element) {
            (0, _$['default'])(element).addClass('aui-layer').html('<div class="aui-inline-dialog-contents">' + element.innerHTML + '</div>');
        }
    });

    (0, _amdify['default'])('aui/inline-dialog2', inlineDialog);
    (0, _globalize['default'])('InlineDialog2', inlineDialog);
    module.exports = inlineDialog;
});
//# sourceMappingURL=../../js/aui/inline-dialog2.js.map