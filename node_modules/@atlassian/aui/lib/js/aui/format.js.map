{"version":3,"sources":["js/aui/format.js"],"names":[],"mappings":"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","file":"js/aui/format.js","sourcesContent":["'use strict';\n\nimport globalize from './internal/globalize';\n\n/**\n * Replaces tokens in a string with arguments, similar to Java's MessageFormat.\n * Tokens are in the form {0}, {1}, {2}, etc.\n *\n * This version also provides support for simple choice formats (excluding floating point numbers) of the form\n * {0,choice,0#0 issues|1#1 issue|1<{0,number} issues}\n *\n * Number format is currently not implemented, tokens of the form {0,number} will simply be printed as {0}\n *\n * @method format\n * @param message the message to replace tokens in\n * @param arg (optional) replacement value for token {0}, with subsequent arguments being {1}, etc.\n * @return {String} the message with the tokens replaced\n * @usage formatString(\"This is a {0} test\", \"simple\");\n */\nfunction formatString (message) {\n    var apos = /'(?!')/g, // founds \"'\", but not \"''\"\n        simpleFormat = /^\\d+$/,\n        numberFormat = /^(\\d+),number$/, // TODO: incomplete, as doesn't support floating point numbers\n        choiceFormat = /^(\\d+)\\,choice\\,(.+)/,\n        choicePart = /^(\\d+)([#<])(.+)/; // TODO: does not work for floating point numbers!\n    // we are caching RegExps, so will not spend time on recreating them on each call\n\n    // formats a value, currently choice and simple replacement are implemented, proper\n    var getParamValue = function (format, args) {\n        // simple substitute\n        /*jshint boss:true */\n        var res = '', match;\n        if (match = format.match(simpleFormat)) { // TODO: heavy guns for checking whether format is a simple number...\n            res = args.length > ++format ? args[format] : ''; // use the argument as is, or use '' if not found\n        }\n\n        // number format\n        else if (match = format.match(numberFormat)) {\n            // TODO: doesn't actually format the number...\n            res = args.length > ++match[1] ? args[match[1]] : '';\n        }\n\n        // choice format\n        else if (match = format.match(choiceFormat)) {\n            // format: \"0,choice,0#0 issues|1#1 issue|1<{0,number} issues\"\n            // match[0]: \"0,choice,0#0 issues|1#1 issue|1<{0,number} issues\"\n            // match[1]: \"0\"\n            // match[2]: \"0#0 issues|1#1 issue|1<{0,number} issues\"\n\n            // get the argument value we base the choice on\n            var value = (args.length > ++match[1] ? args[match[1]] : null);\n            if (value !== null) {\n                // go through all options, checking against the number, according to following formula,\n                // if X < the first entry then the first entry is returned, if X > last entry, the last entry is returned\n                //\n                //    X matches j if and only if limit[j] <= X < limit[j+1]\n                //\n                var options = match[2].split('|');\n\n                var prevOptionValue = null; // holds last passed option\n                for (var i = 0; i < options.length; i++) {\n                    // option: \"0#0 issues\"\n                    // part[0]: \"0#0 issues\"\n                    // part[1]: \"0\"\n                    // part[2]: \"#\"\n                    // part[3]\" \"0 issues\";\n                    var parts = options[i].match(choicePart);\n\n                    // if value is smaller, we take the previous value, or the current if no previous exists\n                    var argValue = parseInt(parts[1], 10);\n                    if (value < argValue) {\n                        if (prevOptionValue) {\n                            res = prevOptionValue;\n                            break;\n                        } else {\n                            res = parts[3];\n                            break;\n                        }\n                    }\n                    // if value is equal the condition, and the match is equality match we accept it\n                    if (value == argValue && parts[2] == '#') {\n                        res = parts[3];\n                        break;\n                    }\n                    else {\n                        // value is greater the condition, fall through to next iteration\n                    }\n\n                    // check whether we are the last option, in which case accept it even if the option does not match\n                    if (i == options.length - 1) {\n                        res = parts[3];\n                    }\n\n                    // retain current option\n                    prevOptionValue = parts[3];\n                }\n\n                // run result through format, as the parts might contain substitutes themselves\n                var formatArgs = [res].concat(Array.prototype.slice.call(args, 1));\n                res = formatString.apply(null, formatArgs);\n            }\n        }\n        return res;\n    };\n\n    // drop in replacement for the token regex\n    // splits the message to return the next accurance of a i18n placeholder.\n    // Does not use regexps as we need to support nested placeholders\n    // text between single ticks ' are ignored\n    var _performTokenRegex = function (message) {\n        var tick = false, openIndex = -1, openCount = 0;\n        for (var i = 0; i < message.length; i++) {\n            // handle ticks\n            var c = message.charAt(i);\n            if (c == \"'\") {\n                // toggle\n                tick = !tick;\n            }\n            // skip if we are between ticks\n            if (tick) {\n                continue;\n            }\n            // check open brackets\n            if (c === '{') {\n                if (openCount === 0) {\n                    openIndex = i;\n                }\n                openCount++;\n            }\n            else if (c === '}') {\n                if (openCount > 0) {\n                    openCount--;\n                    if (openCount === 0) {\n                        // we found a bracket match - generate the result array (\n                        var match = [];\n                        match.push(message.substring(0, i + 1)); // from begin to match\n                        match.push(message.substring(0, openIndex)); // everything until match start\n                        match.push(message.substring(openIndex + 1, i)); // matched content\n                        return match;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    var _formatString = function (message) {\n        var args = arguments;\n        var res = '';\n\n        if (!message) {\n            return res;\n        }\n\n        var match = _performTokenRegex(message);\n\n        while (match) {\n            // reduce message to string after match\n            message = message.substring(match[0].length);\n\n            // add value before match to result\n            res += match[1].replace(apos, '');\n\n            // add formatted parameter\n            res += getParamValue(match[2], args);\n\n            // check for next match\n            match = _performTokenRegex(message); //message.match(token);\n        }\n        // add remaining message to result\n        res += message.replace(apos, '');\n        return res;\n    };\n\n    return _formatString.apply(null, arguments);\n}\n\nglobalize('format', formatString);\n\nexport default formatString;\n"],"sourceRoot":"/source/"}