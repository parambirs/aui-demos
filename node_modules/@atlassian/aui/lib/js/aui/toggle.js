(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['exports', './spin', './internal/attributes', 'jquery', './internal/enforcer', 'skatejs-template-html', './internal/skate', './internal/constants'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports, require('./spin'), require('./internal/attributes'), require('jquery'), require('./internal/enforcer'), require('skatejs-template-html'), require('./internal/skate'), require('./internal/constants'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.spin, global.attributes, global.$, global.enforce, global.skateTemplateHtml, global.skate, global.constants);
        global.toggle = mod.exports;
    }
})(this, function (exports, _spin, _internalAttributes, _jquery, _internalEnforcer, _skatejsTemplateHtml, _internalSkate, _internalConstants) {
    'use strict';

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    var _$ = _interopRequireDefault(_jquery);

    var _enforce = _interopRequireDefault(_internalEnforcer);

    var _skateTemplateHtml = _interopRequireDefault(_skatejsTemplateHtml);

    var _skate = _interopRequireDefault(_internalSkate);

    function getInput(element) {
        return element._input || (element._input = element.querySelector('input'));
    }

    function removedAttributeHandler(attributeName, element) {
        getInput(element).removeAttribute(attributeName);
    }

    function fallbackAttributeHandler(attributeName, element, change) {
        getInput(element).setAttribute(attributeName, change.newValue);
    }

    function getAttributeHandler(attributeName) {
        return {
            removed: removedAttributeHandler.bind(this, attributeName),
            fallback: fallbackAttributeHandler.bind(this, attributeName)
        };
    }

    var idAttributeHandler = {
        removed: removedAttributeHandler.bind(undefined, 'id'),
        fallback: function fallback(element, change) {
            getInput(element).setAttribute('id', '' + change.newValue + _internalConstants.INPUT_SUFFIX);
        }
    };

    var checkedAttributeHandler = {
        removed: function removed(element) {
            removedAttributeHandler.call(this, 'checked', element);
            getInput(element).checked = false;
        },
        fallback: function fallback(element, change) {
            fallbackAttributeHandler.call(this, 'checked', element, change);
            getInput(element).checked = true;
        }
    };

    var labelHandler = {
        removed: function removed(element) {
            getInput(element).removeAttribute('aria-label');
        },
        fallback: function fallback(element, change) {
            getInput(element).setAttribute('aria-label', change.newValue);
        }
    };

    function getTooltipContent() {
        /* jshint validthis: true */
        return this._input.checked ? this.tooltipOn : this.tooltipOff;
    }

    function clickHandler(element, e) {
        if (!element.disabled && !element.busy && e.target !== element._input) {
            element._input.click();
        }
        (0, _internalAttributes.setBooleanAttribute)(element, 'checked', getInput(element).checked);
    }

    function setDisabledForLabels(element, disabled) {
        if (!element.id) {
            return;
        }
        Array.prototype.forEach.call(document.querySelectorAll('aui-label[for="' + element.id + '"]'), function (el) {
            el.disabled = disabled;
        });
    }

    /**
     * Workaround to prevent pressing SPACE on busy state.
     * Preventing click event still makes the toggle flip and revert back.
     * So on CSS side, the input has "pointer-events: none" on busy state.
     */
    function bindEventsToInput(element) {
        element._input.addEventListener('keydown', function (e) {
            if (element.busy && e.keyCode === AJS.keyCode.SPACE) {
                e.preventDefault();
            }
        });
        // prevent toggle can be trigger through SPACE key on Firefox
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
            element._input.addEventListener('click', function (e) {
                if (element.busy) {
                    e.preventDefault();
                }
            });
        }
    }

    (0, _skate['default'])('aui-toggle', {
        template: (0, _skateTemplateHtml['default'])('<input type="checkbox" class="aui-toggle-input">', '<span class="aui-toggle-view">', '<span class="aui-toggle-tick aui-icon aui-icon-small aui-iconfont-success"></span>', '<span class="aui-toggle-cross aui-icon aui-icon-small aui-iconfont-close-dialog"></span>', '</span>'),
        created: function created(element) {
            element._input = getInput(element); // avoid using _input in attribute handlers
            element._tick = element.querySelector('.aui-toggle-tick');
            element._cross = element.querySelector('.aui-toggle-cross');

            (0, _$['default'])(element).tooltip({ title: getTooltipContent, gravity: 's', hoverable: false });
            bindEventsToInput(element);
        },
        attached: function attached(element) {
            (0, _enforce['default'])(element).attributeExists('label');
        },
        events: {
            click: clickHandler
        },
        attributes: {
            id: idAttributeHandler,
            checked: checkedAttributeHandler,
            disabled: getAttributeHandler('disabled'),
            form: getAttributeHandler('form'),
            name: getAttributeHandler('name'),
            value: getAttributeHandler('value'),
            'tooltip-on': { value: AJS.I18n.getText('aui.toggle.on') },
            'tooltip-off': { value: AJS.I18n.getText('aui.toggle.off') },
            label: labelHandler
        },
        prototype: Object.defineProperties({
            focus: function focus() {
                this._input.focus();
                return this;
            }
        }, {
            checked: {
                get: function get() {
                    return this._input.checked;
                },
                set: function set(value) {
                    // Need to explicitly set the property on the checkbox because the
                    // checkbox's property doesn't change with it's attribute after it
                    // is clicked.
                    this._input.checked = value;
                    return (0, _internalAttributes.setBooleanAttribute)(this, 'checked', value);
                },
                configurable: true,
                enumerable: true
            },
            disabled: {
                get: function get() {
                    return this._input.disabled;
                },
                set: function set(value) {
                    return (0, _internalAttributes.setBooleanAttribute)(this, 'disabled', value);
                },
                configurable: true,
                enumerable: true
            },
            form: {
                get: function get() {
                    return this._input.form;
                },
                set: function set(value) {
                    // This setter does nothing according to the HTML5 spec.
                    return this._input.form = value;
                },
                configurable: true,
                enumerable: true
            },
            name: {
                get: function get() {
                    return this._input.name;
                },
                set: function set(value) {
                    this.setAttribute('name', value);
                    return value;
                },
                configurable: true,
                enumerable: true
            },
            value: {
                get: function get() {
                    return this._input.value;
                },
                set: function set(value) {
                    // Setting the value of an input to null sets it to empty string.
                    this.setAttribute('value', value === null ? '' : value);
                    return value;
                },
                configurable: true,
                enumerable: true
            },
            busy: {
                get: function get() {
                    return this._input.getAttribute('aria-busy') === 'true';
                },
                set: function set(value) {
                    (0, _internalAttributes.setBooleanAttribute)(this, 'busy', value);
                    if (value) {
                        this._input.setAttribute('aria-busy', 'true');
                        this._input.indeterminate = true;
                        if (this.checked) {
                            (0, _$['default'])(this._input).addClass('indeterminate-checked');
                            (0, _$['default'])(this._tick).spin({ zIndex: null });
                        } else {
                            (0, _$['default'])(this._cross).spin({ zIndex: null, color: 'black' });
                        }
                    } else {
                        (0, _$['default'])(this._input).removeClass('indeterminate-checked');
                        this._input.indeterminate = false;
                        this._input.removeAttribute('aria-busy');
                        (0, _$['default'])(this._cross).spinStop();
                        (0, _$['default'])(this._tick).spinStop();
                    }
                    setDisabledForLabels(this, !!value);
                    return value;
                },
                configurable: true,
                enumerable: true
            }
        })
    });
});
//# sourceMappingURL=../../js/aui/toggle.js.map